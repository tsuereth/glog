+++
category = [ "Playing A Game" ]
date = "2015-12-29T20:08:35-08:00"
draft = false
game = [ "Human Resource Machine" ]
platform = [ "PC" ]
rating = [ "Good" ]
title = "If only real humans would obey my instructions like this"
+++

More so than <game:TIS-100>, <game:Human Resource Machine> makes me appreciate the fact that C is a high-level language.  Because while TIS-100 (as with <game:SpaceChem> and <game:Infinifactory> before it) upturns programming fundamentals to build a game about concurrency/parallelism, HRM is actually more like a real, tiny but fully-functional computer.  And it will remind any computer science student of what it's like to take <i>conditional statements</i> and <i>variables</i> for granted.

(Specifically: HRM provides an unconditional jump, and jumps when zero and negative, but not for a positive case; so creating logical blocks of code for this can make for a very messy jump diagram.  And while most of HRM's puzzles include memory in the form of addressable locations, managing all of the requried "copy from" and "copy to" instructions manually gets pretty exhausting.)

So while Human Resource Machine is firmly in the category of "metaphorical programming games" - which I'm incredibly happy about - it's still fresh in the context of more abstract games like TIS-100.  Ignoring Tomorrow Corporation's surreal semi-dystopian setting, this game's levels feel a lot like real-world assembly programming challenges.

But there are some problems with HRM that bring the experience down somewhat, mostly in its UI.  Contrary to TIS-100's limited space for writing instructions, HRM has a scrollable area for lengthy programs; but this doesn't scale well with the later levels, making it difficult to navigate jump destinations.  The game supports adding comments to code and labels to memory locations, but forces you to write them with a mouse, instead of just typing letters on the keyboard.  And while the "run" speed can be slowed down and sped up, even the fastest setting is way too slow for the last few levels, taking whole minutes to run through nested memory-scanning loops.

Still, despite these flaws, Human Resource Machine is a pretty fun programming game.  What interferes the most with its value proposition is that it's fairly short.  Although I'm totally stumped on an optional level for <i>prime factorization</i> - which is just, I don't have to tell you about that - the rest of the game only took me about three hours to plow through.

I'll be spending some more time on that, though, and on trying to meet the optimization challenges in other levels.  This may not be as much of an ego-stroke as literally comparing my performance numbers to my friends' (as the Zachtronics games do), but, my pride requires I do it anyway.

<b>Better than</b>: <game:Little Inferno>  
<b>Not as good as</b>: <game:TIS-100> -- but maybe just because I'm a masochist  
<b>And the ending</b>: Is a satisfyingly humorous send-off.

<i>Progress: Finished all but Prime Factory, missing a bunch of optimization challenges.</i>
